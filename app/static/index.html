<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>GenesisPrediction v2 - Home</title>
  <link rel="stylesheet" href="/static/app.css" />
</head>

<body>
  <header class="app-header">
    <div class="header-inner">
      <div class="brand">GenesisPrediction v2</div>

      <nav class="nav">
        <a class="nav-link is-active" href="/static/index.html">Home</a>
        <a class="nav-link" href="/static/overlay.html">Overlay</a>
        <a class="nav-link" href="/static/sentiment.html">Sentiment</a>
      </nav>

      <div class="badge" title="Single Source of Truth: files under /analysis/">
        <span class="dot"></span>
        <span>GUI is read-only (SST)</span>
      </div>
    </div>
  </header>

  <main class="app-main">
    <div class="container">

      <section class="card">
        <div class="card-header">
          <div>
            <h2 class="card-title">Today / Latest</h2>
            <div class="card-sub">正本（PNG/CSV/HTML）を読むだけ。GUIは再計算しません。</div>
          </div>

          <div class="date-controls">
            <div class="pill" id="datePill">date: -</div>
            <button class="btn" id="btnPrev">◀</button>
            <button class="btn" id="btnNext">▶</button>
            <button class="btn" id="btnToday">Today</button>
            <button class="btn" id="btnLatest">Latest</button>
          </div>
        </div>

        <div class="kpi-grid">
          <div class="kpi">
            <div class="kpi-label">articles</div>
            <div class="kpi-value" id="kpiArticles">-</div>
          </div>
          <div class="kpi">
            <div class="kpi-label">risk</div>
            <div class="kpi-value" id="kpiRisk">-</div>
          </div>
          <div class="kpi">
            <div class="kpi-label">positive</div>
            <div class="kpi-value" id="kpiPositive">-</div>
          </div>
          <div class="kpi">
            <div class="kpi-label">uncertainty</div>
            <div class="kpi-value" id="kpiUnc">-</div>
          </div>
        </div>

        <div class="actions">
          <button class="btn btn-primary" id="btnOpenOverlay">Open Overlay</button>
          <button class="btn btn-primary" id="btnOpenSentiment">Open Sentiment</button>
          <button class="btn btn-primary" id="btnOpenDigest">Open Digest HTML</button>
        </div>

        <div class="warn" id="warnBox" style="display:none;"></div>
      </section>

      <section class="card">
        <div class="card-header">
          <div>
            <h2 class="card-title">FX preview</h2>
            <div class="card-sub" id="fxSource">Source: -</div>
          </div>
          <div class="small-note">dated があれば dated を優先。なければ latest にフォールバック。</div>
        </div>

        <div class="img-wrap">
          <img id="fxImg" alt="FX overlay" loading="lazy" />
        </div>
      </section>

      <!-- FX decision (C: ViewModel-first, B: API fallback) -->
      <section class="card" id="fxDecisionCard" style="display:none;">
        <div class="card-header">
          <div>
            <h2 class="card-title">FX decision</h2>
            <div class="card-sub" id="fxDecisionSource">Source: -</div>
          </div>
          <div class="small-note">ViewModel の fx_block を優先（無い場合のみ /api/fx_decision にフォールバック）</div>
        </div>

        <div style="display:flex; flex-direction:column; gap:10px;">
          <div style="display:flex; align-items:baseline; gap:12px; flex-wrap:wrap;">
            <div style="font-size:18px; font-weight:700;">本日の判断：</div>
            <div id="fxDecisionValue" style="font-size:22px; font-weight:800;">-</div>
            <div class="muted" id="fxDecisionConf" style="margin-left:auto;">confidence: -</div>
          </div>

          <div>
            <div style="font-weight:700; margin-bottom:6px;">為替要因</div>
            <ul id="fxDecisionReasons" style="margin:0; padding-left:18px;"></ul>
          </div>

          <div id="fxDecisionRefWrap" style="display:none;">
            <div style="font-weight:700; margin-bottom:6px;">国際情勢（参考）</div>
            <ul id="fxDecisionRefs" style="margin:0; padding-left:18px;"></ul>
          </div>

          <div id="fxDecisionWatchWrap" style="display:none;">
            <div style="font-weight:700; margin-bottom:6px;">注視（watchlist）</div>
            <ul id="fxDecisionWatch" style="margin:0; padding-left:18px;"></ul>
          </div>

          <div class="muted" id="fxDecisionDisclaimer" style="font-size:12px; line-height:1.5;"></div>
        </div>
      </section>

      <section class="card">
        <div class="card-header">
          <div>
            <h2 class="card-title">Articles & Sentiment</h2>
            <div class="card-sub">/analysis/sentiment_latest.json をそのまま描画（Homeはダイジェストを埋め込みません）</div>
          </div>
          <div class="small-note" id="sentMeta">-</div>
        </div>

        <div class="list-head">
          <div class="muted" id="sentCount">0 items</div>
          <div class="row">
            <button class="btn" id="btnCollapse">Collapse</button>
            <button class="btn" id="btnExpand">Expand</button>
          </div>
        </div>

        <div class="sent-list" id="sentList"></div>

        <div class="empty" id="sentEmpty" style="display:none;">
          No sentiment items found.
        </div>
      </section>

    </div>
  </main>

  <footer class="app-footer">
    GenesisPrediction v2 — static GUI (SST). Reads files under <code>/analysis/</code> only.
  </footer>

<script>
(() => {
  const qs = new URLSearchParams(location.search);
  const dateParam = qs.get("date"); // YYYY-MM-DD or null

  const pad2 = (n) => String(n).padStart(2, "0");
  const fmtDate = (d) => `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())}`;

  const parseDate = (s) => {
    const m = /^(\d{4})-(\d{2})-(\d{2})$/.exec(s || "");
    if (!m) return null;
    const dt = new Date(Number(m[1]), Number(m[2]) - 1, Number(m[3]));
    return Number.isFinite(dt.getTime()) ? dt : null;
  };

  const addDays = (d, delta) => {
    const x = new Date(d.getTime());
    x.setDate(x.getDate() + delta);
    return x;
  };

  const setText = (id, v) => document.getElementById(id).textContent = v;

  const toFixed6 = (v) => {
    const n = Number(v);
    return Number.isFinite(n) ? n.toFixed(6) : "-";
  };

  async function fetchJson(url){
    const r = await fetch(url, { cache: "no-store" });
    if(!r.ok) throw new Error(`${r.status} ${r.statusText}`);
    return await r.json();
  }

  async function exists(url){
    try{
      const r = await fetch(url, { method: "HEAD", cache: "no-store" });
      return r.ok;
    }catch(_){
      return false;
    }
  }

  function clear(el){ while(el.firstChild) el.removeChild(el.firstChild); }
  function safeText(x){ return (x === null || x === undefined) ? "" : String(x); }

  // Paths
  const SENT_LATEST = "/analysis/sentiment_latest.json";
  const SENT_DATED  = (d) => `/analysis/sentiment_${d}.json`;

  const DIGEST_LATEST = "/analysis/daily_news_digest_latest.html";
  const DIGEST_DATED  = (d) => `/analysis/daily_news_digest_${d}.html`;

  const FX_LATEST = "/analysis/jpy_thb_remittance_overlay.png";
  const FX_DATED  = (d) => `/analysis/fx_overlay_${d}.png`;

  // C: view_model API
  const VIEWMODEL_API = (d) => `/api/view_model/${d}`;
  // B: fx_decision API fallback
  const FX_DECISION_API = (d) => `/api/fx_decision/${d}`;

  // Buttons
  const warnBox = document.getElementById("warnBox");
  const gotoDate = (d) => location.href = `/static/index.html?date=${d}`;

  document.getElementById("btnToday").addEventListener("click", () => gotoDate(fmtDate(new Date())));
  document.getElementById("btnLatest").addEventListener("click", () => location.href = `/static/index.html`);

  document.getElementById("btnPrev").addEventListener("click", () => {
    const d = parseDate(dateParam) || new Date();
    gotoDate(fmtDate(addDays(d, -1)));
  });

  document.getElementById("btnNext").addEventListener("click", () => {
    const d = parseDate(dateParam) || new Date();
    gotoDate(fmtDate(addDays(d, +1)));
  });

  document.getElementById("btnOpenOverlay").addEventListener("click", () => {
    const url = dateParam ? `/static/overlay.html?date=${dateParam}` : `/static/overlay.html`;
    window.open(url, "_blank");
  });

  document.getElementById("btnOpenSentiment").addEventListener("click", () => {
    const url = dateParam ? `/static/sentiment.html?date=${dateParam}` : `/static/sentiment.html`;
    window.open(url, "_blank");
  });

  document.getElementById("btnOpenDigest").addEventListener("click", async () => {
    if (dateParam) {
      const dUrl = DIGEST_DATED(dateParam);
      if (await exists(dUrl)) return window.open(dUrl, "_blank");
    }
    window.open(DIGEST_LATEST, "_blank");
  });

  // collapse/expand list
  const sentList = document.getElementById("sentList");
  document.getElementById("btnCollapse").addEventListener("click", () => sentList.classList.add("is-collapsed"));
  document.getElementById("btnExpand").addEventListener("click", () => sentList.classList.remove("is-collapsed"));

  // Load sentiment (KPI source)
  async function loadSentiment(){
    warnBox.style.display = "none";
    warnBox.textContent = "";

    let json = null;
    let used = "latest";

    try{
      if (dateParam) {
        json = await fetchJson(SENT_DATED(dateParam));
        used = "dated";
      } else {
        json = await fetchJson(SENT_LATEST);
        used = "latest";
      }
    }catch(e){
      if (dateParam) {
        try{
          json = await fetchJson(SENT_LATEST);
          used = "latest_fallback";
        }catch(e2){
          warnBox.style.display = "block";
          warnBox.textContent = `sentiment json load failed: ${String(e2.message || e2)}`;
          return null;
        }
      } else {
        warnBox.style.display = "block";
        warnBox.textContent = `sentiment_latest.json not found: ${String(e.message || e)}`;
        return null;
      }
    }

    const date = (json && json.date) ? String(json.date) : (dateParam || fmtDate(new Date()));
    setText("datePill", `date: ${date}`);

    setText("kpiArticles", json.articles ?? json.items?.length ?? "-");
    setText("kpiRisk", toFixed6(json.risk));
    setText("kpiPositive", toFixed6(json.positive));
    setText("kpiUnc", toFixed6(json.uncertainty));

    const total = Array.isArray(json.items) ? json.items.length : 0;
    setText("sentMeta", `date=${date} / source=${used}`);
    setText("sentCount", `${total} items`);

    const empty = document.getElementById("sentEmpty");
    clear(sentList);

    if (!total) {
      empty.style.display = "block";
      return json;
    }
    empty.style.display = "none";

    // minimal list render (title + source only)
    for (const it of json.items) {
      const row = document.createElement("div");
      row.className = "item";

      const img = document.createElement("img");
      img.className = "thumb";
      img.alt = "";
      img.loading = "lazy";
      img.src = it.image_url || "";
      img.onerror = () => { img.src = ""; img.classList.add("thumb-empty"); };
      row.appendChild(img);

      const body = document.createElement("div");
      body.className = "item-body";

      const title = document.createElement("a");
      title.className = "item-title";
      title.href = it.url || "#";
      title.target = "_blank";
      title.rel = "noopener noreferrer";
      title.textContent = it.title || "(no title)";
      body.appendChild(title);

      const meta = document.createElement("div");
      meta.className = "item-meta";
      meta.textContent = (typeof it.source === "string") ? it.source : (it.source?.name || it.source?.id || "-");
      body.appendChild(meta);

      row.appendChild(body);
      sentList.appendChild(row);
    }

    return json;
  }

  // Load FX preview
  async function loadFx(){
    const fxImg = document.getElementById("fxImg");
    const fxSource = document.getElementById("fxSource");

    let url = FX_LATEST;
    let used = "latest";

    if (dateParam) {
      const dUrl = FX_DATED(dateParam);
      if (await exists(dUrl)) {
        url = dUrl;
        used = "dated";
      }
    }

    fxImg.src = url + `?t=${Date.now()}`;
    fxSource.textContent = `Source: ${url} (${used})`;
  }

  // Render FX card from fx_block shape
  function renderFxDecisionFromBlock(fxBlock, sourceLabel){
    const card = document.getElementById("fxDecisionCard");
    const srcEl = document.getElementById("fxDecisionSource");
    const decEl = document.getElementById("fxDecisionValue");
    const confEl = document.getElementById("fxDecisionConf");
    const reasonsUl = document.getElementById("fxDecisionReasons");

    const refWrap = document.getElementById("fxDecisionRefWrap");
    const refUl = document.getElementById("fxDecisionRefs");

    const watchWrap = document.getElementById("fxDecisionWatchWrap");
    const watchUl = document.getElementById("fxDecisionWatch");

    const disEl = document.getElementById("fxDecisionDisclaimer");

    // reset
    card.style.display = "none";
    srcEl.textContent = "Source: -";
    decEl.textContent = "-";
    confEl.textContent = "confidence: -";
    reasonsUl.innerHTML = "";
    refWrap.style.display = "none";
    refUl.innerHTML = "";
    watchWrap.style.display = "none";
    watchUl.innerHTML = "";
    disEl.textContent = "";

    if (!fxBlock || typeof fxBlock !== "object") return;

    card.style.display = "block";
    srcEl.textContent = `Source: ${sourceLabel}`;

    const decision = fxBlock.decision ?? fxBlock.fx_decision ?? "";
    decEl.textContent = safeText(decision);

    const conf = fxBlock.confidence;
    confEl.textContent = `confidence: ${Number.isFinite(Number(conf)) ? Number(conf).toFixed(2) : "-"}`;

    const reasons = Array.isArray(fxBlock.fx_reasons) ? fxBlock.fx_reasons : [];
    if (reasons.length === 0) {
      const li = document.createElement("li");
      li.textContent = "(no reasons)";
      reasonsUl.appendChild(li);
    } else {
      for (const t of reasons.slice(0, 3)) {
        const li = document.createElement("li");
        li.textContent = safeText(t);
        reasonsUl.appendChild(li);
      }
    }

    const refs = Array.isArray(fxBlock.reference) ? fxBlock.reference
              : (Array.isArray(fxBlock.analyzer_reference) ? fxBlock.analyzer_reference : []);
    if (refs.length) {
      refWrap.style.display = "block";
      for (const r of refs.slice(0, 5)) {
        const li = document.createElement("li");
        const topic = safeText(r.topic);
        const label = safeText(r.label);
        const impact = safeText(r.impact);
        li.textContent = `${topic}${label ? " [" + label + "]" : ""}${impact ? " - " + impact : ""}`;
        refUl.appendChild(li);
      }
    }

    const watch = Array.isArray(fxBlock.watchlist) ? fxBlock.watchlist : [];
    if (watch.length) {
      watchWrap.style.display = "block";
      for (const w of watch.slice(0, 5)) {
        const li = document.createElement("li");
        const topic = safeText(w.topic);
        const status = safeText(w.status);
        const reason = safeText(w.reason);
        li.textContent = `${topic}${status ? " - " + status : ""}${reason ? " / " + reason : ""}`;
        watchUl.appendChild(li);
      }
    }

    disEl.textContent = safeText(fxBlock.disclaimer || "本判断は補助情報であり、最終的な送金判断は利用者自身の責任で行ってください。");
  }

  // Load FX decision: C (view_model.fx_block) -> B (api)
  async function loadFxDecision(effectiveDate){
    if (!effectiveDate) return;

    // C: ViewModel first
    try{
      const vm = await fetchJson(VIEWMODEL_API(effectiveDate));
      if (vm && vm.fx_block) {
        return renderFxDecisionFromBlock(vm.fx_block, `view_model:${effectiveDate}`);
      }
    }catch(_e){
      // ignore and fall back
    }

    // B: API fallback
    try{
      const obj = await fetchJson(FX_DECISION_API(effectiveDate));
      // normalize api -> fx_block-ish
      const fxBlock = {
        date: effectiveDate,
        decision: obj.fx_decision ?? obj.decision,
        confidence: obj.confidence,
        fx_reasons: obj.fx_reasons || [],
        reference: obj.analyzer_reference || obj.reference || [],
        watchlist: obj.watchlist || [],
        disclaimer: obj.disclaimer
      };
      return renderFxDecisionFromBlock(fxBlock, `api_fx_decision:${effectiveDate}`);
    }catch(_e2){
      // no fx info -> keep hidden
      return;
    }
  }

  // Boot
  (async () => {
    const sent = await loadSentiment();
    await loadFx();

    const effectiveDate =
      (sent && sent.date) ? String(sent.date) :
      (dateParam || fmtDate(new Date()));

    await loadFxDecision(effectiveDate);
  })();
})();
</script>

</body>
</html>

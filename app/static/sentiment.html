<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>GenesisPrediction v2 - Sentiment</title>

  <!-- SST: app.css を使う（GUIの見た目はここに寄せる） -->
  <link rel="stylesheet" href="./app.css" />

  <style>
    /* app.css が想定外でも最低限「崩壊」しないための保険（最小） */
    .gp-container{max-width:1100px;margin:0 auto;padding:24px 16px 48px;}
    .gp-topbar{display:flex;align-items:center;justify-content:space-between;gap:16px;margin:10px 0 18px;}
    .gp-brand{display:flex;align-items:center;gap:10px;min-width:200px;}
    .gp-dot{width:10px;height:10px;border-radius:999px;background:#2dd4bf;box-shadow:0 0 0 3px rgba(45,212,191,.15);}
    .gp-nav{display:flex;gap:10px;align-items:center;justify-content:center;flex:1;}
    .gp-nav a{display:inline-block;padding:6px 12px;border-radius:999px;text-decoration:none;border:1px solid rgba(255,255,255,.12);color:inherit;opacity:.9}
    .gp-nav a:hover{opacity:1}
    .gp-pill{display:inline-flex;align-items:center;gap:8px;padding:6px 12px;border-radius:999px;border:1px solid rgba(255,255,255,.12)}
    .gp-grid{display:grid;grid-template-columns: 1.1fr .9fr;gap:16px;align-items:start}
    @media (max-width: 980px){.gp-grid{grid-template-columns:1fr}}
    .gp-card{border:1px solid rgba(255,255,255,.12);border-radius:16px;padding:16px;background:rgba(255,255,255,.02)}
    .gp-title{font-size:34px;margin:8px 0 6px}
    .gp-sub{opacity:.85;line-height:1.5;margin:0 0 14px}
    .gp-kpis{display:grid;grid-template-columns:repeat(4,1fr);gap:10px;margin-top:10px}
    @media (max-width: 980px){.gp-kpis{grid-template-columns:repeat(2,1fr)}}
    .gp-kpi{border:1px solid rgba(255,255,255,.10);border-radius:12px;padding:10px 12px}
    .gp-kpi .k{opacity:.75;font-size:12px}
    .gp-kpi .v{font-size:20px;margin-top:4px;font-variant-numeric:tabular-nums}
    .gp-controls{display:flex;flex-wrap:wrap;gap:8px;margin:10px 0 10px}
    .gp-btn{cursor:pointer;border:1px solid rgba(255,255,255,.12);background:transparent;color:inherit;border-radius:999px;padding:6px 10px;font-size:12px}
    .gp-btn:hover{border-color:rgba(255,255,255,.22)}
    .gp-filters{display:grid;grid-template-columns: 1fr 170px 170px auto;gap:10px;align-items:end;margin-top:10px}
    @media (max-width: 980px){.gp-filters{grid-template-columns:1fr 1fr;}}
    .gp-field label{display:block;font-size:12px;opacity:.8;margin-bottom:6px}
    .gp-field input,.gp-field select{width:100%;padding:8px 10px;border-radius:10px;border:1px solid rgba(255,255,255,.12);background:rgba(0,0,0,.15);color:inherit}
    .gp-tabs{display:flex;flex-wrap:wrap;gap:8px;margin-top:10px}
    .gp-tab{cursor:pointer;border:1px solid rgba(255,255,255,.12);background:transparent;color:inherit;border-radius:999px;padding:6px 10px;font-size:12px;opacity:.9}
    .gp-tab.active{border-color:rgba(45,212,191,.6);box-shadow:0 0 0 3px rgba(45,212,191,.12);opacity:1}
    .gp-small{font-size:12px;opacity:.75}
    .gp-tablewrap{margin-top:16px}
    table{width:100%;border-collapse:collapse}
    th,td{border-bottom:1px solid rgba(255,255,255,.08);padding:10px 8px;vertical-align:top}
    th{font-size:12px;opacity:.75;text-align:left}
    td{font-size:13px}
    .thumb{width:44px;height:44px;border-radius:10px;object-fit:cover;border:1px solid rgba(255,255,255,.12);background:rgba(255,255,255,.04)}
    .t-title a{color:inherit;text-decoration:none}
    .t-title a:hover{text-decoration:underline}
    .badge{display:inline-flex;align-items:center;gap:6px;border:1px solid rgba(255,255,255,.12);border-radius:999px;padding:2px 8px;font-size:12px;opacity:.95}
    .dot{width:8px;height:8px;border-radius:999px;background:#94a3b8}
    .dot.ok{background:#2dd4bf}
    .dot.risk{background:#fb7185}
    .net{font-variant-numeric:tabular-nums}
    .net.pos{color:#2dd4bf;font-weight:700}
    .net.neg{color:#fb7185;font-weight:700}
    .num{font-variant-numeric:tabular-nums}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;}
    .chartbox{margin-top:12px}
    canvas{width:100%;height:180px;border:1px solid rgba(255,255,255,.10);border-radius:12px;background:rgba(0,0,0,.10)}
  </style>
</head>

<body>
  <div class="gp-container">
    <div class="gp-topbar">
      <div class="gp-brand">
        <span class="gp-dot" aria-hidden="true"></span>
        <div class="mono" style="font-size:14px;opacity:.95;">GenesisPrediction v2</div>
      </div>

      <div class="gp-nav mono">
        <a href="./index.html">Home</a>
        <a href="./overlay.html">Overlay</a>
        <a href="./sentiment.html">Sentiment</a>
      </div>

      <div class="gp-pill mono" id="healthPill">
        <span class="dot ok" id="healthDot"></span>
        <span id="healthText">OK: --</span>
      </div>
    </div>

    <h1 class="gp-title">Sentiment（記事別）</h1>
    <p class="gp-sub">
      <span class="mono">/analysis/sentiment_latest.json</span>（items）と
      <span class="mono">/analysis/daily_news_categorized_latest.json</span>（母集団）を join して表示します（GUI読み取り専用）。
      join が成立しない日（overlap=0 等）は、自動で <b>sentiment 側を母集団</b>に切り替えて「スコアが出ない事故」を避けます（B）。
    </p>

    <div class="gp-grid">
      <div class="gp-card">
        <div style="display:flex;align-items:center;justify-content:space-between;gap:12px;">
          <div class="mono" style="font-size:18px;font-weight:700;">Controls</div>
          <div class="gp-small mono" id="noteLine">loading...</div>
        </div>

        <div class="gp-controls">
          <button class="gp-btn mono" id="btnReload">Reload</button>
          <button class="gp-btn mono" id="btnReset">Reset filters</button>

          <button class="gp-btn mono" id="btnOpenCategorized">Open daily_news_categorized*.json</button>
          <button class="gp-btn mono" id="btnOpenSentiment">Open sentiment_latest.json</button>
          <button class="gp-btn mono" id="btnOpenTimeseries">Open sentiment_timeseries.csv</button>
        </div>

        <div class="gp-kpis">
          <div class="gp-kpi">
            <div class="k mono">date</div>
            <div class="v mono" id="kpiDate">--</div>
          </div>
          <div class="gp-kpi">
            <div class="k mono">articles</div>
            <div class="v mono" id="kpiArticles">--</div>
          </div>
          <div class="gp-kpi">
            <div class="k mono">risk</div>
            <div class="v mono num" id="kpiRisk">--</div>
          </div>
          <div class="gp-kpi">
            <div class="k mono">positive</div>
            <div class="v mono num" id="kpiPos">--</div>
          </div>
          <div class="gp-kpi" style="grid-column: span 2;">
            <div class="k mono">uncertainty</div>
            <div class="v mono num" id="kpiUnc">--</div>
          </div>
          <div class="gp-kpi" style="grid-column: span 2;">
            <div class="k mono">note</div>
            <div class="v mono" style="font-size:13px;line-height:1.3;" id="kpiNote">--</div>
          </div>
        </div>

        <div class="gp-tabs" id="catTabs"></div>

        <div class="gp-filters">
          <div class="gp-field">
            <label class="mono">search (title/source)</label>
            <input id="q" placeholder="e.g. nigeria / russia / trump ..." />
          </div>
          <div class="gp-field">
            <label class="mono">source</label>
            <select id="sourceSel"></select>
          </div>
          <div class="gp-field">
            <label class="mono">sort</label>
            <select id="sortSel">
              <option value="risk_desc">risk ↓</option>
              <option value="pos_desc">positive ↓</option>
              <option value="unc_desc">uncertainty ↓</option>
              <option value="net_asc">net ↑（risk先頭）</option>
              <option value="net_desc">net ↓（positive先頭）</option>
              <option value="time_desc">time ↓</option>
            </select>
          </div>
          <div class="gp-field">
            <label class="mono">&nbsp;</label>
            <label class="mono" style="display:flex;gap:8px;align-items:center;">
              <input type="checkbox" id="showMissing" checked />
              show missing
            </label>
          </div>
        </div>

        <div class="gp-small mono" id="statLine" style="margin-top:10px;">--</div>

        <div class="chartbox">
          <div class="mono" style="font-size:14px;font-weight:700;margin-bottom:8px;">Sentiment Trend</div>
          <canvas id="trend"></canvas>
          <div class="gp-small mono" style="margin-top:6px;">※ risk / positive / uncertainty を <b>3段分離</b> で描画（timeseries が無ければ空）。</div>
        </div>
      </div>

      <div class="gp-card">
        <div class="mono" style="font-size:18px;font-weight:700;">How it works</div>
        <div class="gp-small mono" style="margin-top:10px;line-height:1.55;">
          1) GET <span class="mono">/analysis/daily_news_categorized_latest.json</span>（母集団 / category layer）<br/>
          2) GET <span class="mono">/analysis/sentiment_latest.json</span>（items / scores）<br/>
          3) join key 優先順：<span class="mono">norm_url → url(正規化) → title+source → title</span><br/>
          4) overlap が低い/ゼロなら <b>base を sentiment に自動切替</b>（B）<br/>
          5) フィルタ・ソート・missing 表示切替
        </div>

        <pre class="mono" id="debugBox" style="margin-top:12px;white-space:pre-wrap;opacity:.85;line-height:1.45;"></pre>
      </div>
    </div>

    <div class="gp-card gp-tablewrap">
      <div class="mono" style="font-size:18px;font-weight:700;margin-bottom:10px;">Articles &amp; Sentiment</div>
      <div style="overflow:auto;">
        <table>
          <thead>
            <tr>
              <th class="mono">thumb</th>
              <th class="mono">title</th>
              <th class="mono">category</th>
              <th class="mono">status</th>
              <th class="mono">risk</th>
              <th class="mono">positive</th>
              <th class="mono">uncertainty</th>
              <th class="mono">net*</th>
            </tr>
          </thead>
          <tbody id="tbody">
            <tr><td colspan="8" class="mono">loading...</td></tr>
          </tbody>
        </table>
      </div>
      <div class="gp-small mono" style="margin-top:10px;">
        * net は存在する場合のみ表示。無ければ risk/pos/unc の推定（可視）/ missing。
      </div>
    </div>
  </div>

<script>
(() => {
  // -----------------------
  // Utilities
  // -----------------------
  const $ = (id) => document.getElementById(id);

  function fmt6(x){
    if (x === null || x === undefined || Number.isNaN(x)) return "—";
    return Number(x).toFixed(6);
  }
  function fmt3(x){
    if (x === null || x === undefined || Number.isNaN(x)) return "—";
    return Number(x).toFixed(3);
  }
  function safeStr(v){
    if (v === null || v === undefined) return "";
    if (typeof v === "string") return v;
    if (typeof v === "number") return String(v);
    if (typeof v === "object") {
      // {name: "..."} 等は name を優先
      if (typeof v.name === "string") return v.name;
      if (typeof v.domain === "string") return v.domain;
      if (typeof v.title === "string") return v.title;
      try { return JSON.stringify(v); } catch(e) { return String(v); }
    }
    return String(v);
  }

  function decodeHtmlEntities(s){
    if (!s) return "";
    const txt = document.createElement("textarea");
    txt.innerHTML = s;
    return txt.value;
  }

  function normalizeUrl(u){
    if (!u) return "";
    let raw = decodeHtmlEntities(String(u)).trim();
    if (!raw) return "";
    if (raw.startsWith("//")) raw = "https:" + raw;

    // strip query/hash
    raw = raw.replace(/#.*$/g, "");
    raw = raw.replace(/\?.*$/g, "");

    // ensure scheme
    if (!/^[a-zA-Z][a-zA-Z0-9+\-.]*:\/\//.test(raw)) {
      raw = "https://" + raw.replace(/^\/+/, "");
    }

    // lowercase scheme + host, drop www.
    const m = raw.match(/^([a-zA-Z][a-zA-Z0-9+\-.]*:\/\/)([^\/]+)(\/.*)?$/);
    if (!m) return raw.toLowerCase().replace(/\/$/, "");
    let scheme = m[1].toLowerCase();
    let host = (m[2] || "").toLowerCase();
    let path = m[3] || "";
    if (host.startsWith("www.")) host = host.slice(4);
    let out = scheme + host + path;
    out = out.replace(/\/$/, "");
    return out;
  }

  function pick(obj, keys){
    if (!obj || typeof obj !== "object") return null;
    for (const k of keys){
      if (k in obj) return obj[k];
    }
    return null;
  }

  function pickUrlAny(o){
    if (!o || typeof o !== "object") return "";
    const direct = pick(o, ["norm_url","url","link","href","article_url","articleUrl","canonical_url","canonicalUrl","final_url","finalUrl","resolved_url","resolvedUrl"]);
    if (typeof direct === "string" && direct.trim()) return direct.trim();
    for (const base of ["article","meta","raw","item","news","data"]){
      const b = o[base];
      if (b && typeof b === "object") {
        const v = pickUrlAny(b);
        if (v) return v;
      }
    }
    return "";
  }

  function pickTitleAny(o){
    if (!o || typeof o !== "object") return "";
    const direct = pick(o, ["title","headline","name","subject"]);
    const s = safeStr(direct).trim();
    if (s) return decodeHtmlEntities(s);
    for (const base of ["article","meta","raw","item","news","data"]){
      const b = o[base];
      if (b && typeof b === "object") {
        const v = pickTitleAny(b);
        if (v) return v;
      }
    }
    return "";
  }

  function pickSourceAny(o){
    if (!o || typeof o !== "object") return "";
    const direct = pick(o, ["source","publisher","site","domain"]);
    const s = safeStr(direct).trim();
    if (s) return s;
    for (const base of ["article","meta","raw","item","news","data"]){
      const b = o[base];
      if (b && typeof b === "object") {
        const v = pickSourceAny(b);
        if (v) return v;
      }
    }
    return "";
  }

  function buildKeys({urlNorm, urlRaw, title, source}){
    const keys = [];
    const u1 = urlNorm ? urlNorm : normalizeUrl(urlRaw);
    if (u1) keys.push("u:" + u1);
    if (urlRaw) keys.push("u2:" + String(urlRaw).trim());
    const tt = (title || "").trim().toLowerCase();
    const ss = (source || "").trim().toLowerCase();
    if (tt) keys.push("t:" + tt);
    if (tt && ss) keys.push("ts:" + tt + "||" + ss);

    // unique
    const out = [];
    const seen = new Set();
    for (const k of keys){
      if (k && !seen.has(k)){
        seen.add(k);
        out.push(k);
      }
    }
    return out;
  }

  function pickScoreTriplet(s){
    // sentiment item から risk/pos/unc/net を拾う（多形対応）
    const net = pick(s, ["net","sent","sentiment","sentiment_score","score","raw_score"]);
    const risk = pick(s, ["risk","risk_score","riskScore"]);
    const pos = pick(s, ["pos","positive","pos_score","posScore"]);
    const unc = pick(s, ["unc","uncertainty","unc_score","uncScore"]);

    const n = (net === null || net === undefined) ? null : Number(net);
    const r = (risk === null || risk === undefined) ? null : Number(risk);
    const p = (pos === null || pos === undefined) ? null : Number(pos);
    const u = (unc === null || unc === undefined) ? null : Number(unc);

    return { net: Number.isFinite(n) ? n : null, risk: Number.isFinite(r) ? r : null, pos: Number.isFinite(p) ? p : null, unc: Number.isFinite(u) ? u : null };
  }

  // -----------------------
  // Data load
  // -----------------------
  const qp = new URLSearchParams(location.search);
  const dateParam = (qp.get("date") || "latest").trim();

  const analysisBase = "/analysis";
  const catLatestUrl = `${analysisBase}/daily_news_categorized_latest.json`;
  const sentLatestUrl = `${analysisBase}/sentiment_latest.json`;
  const tsUrl = `${analysisBase}/sentiment_timeseries.csv`;

  // dated (optional)
  const catDatedUrl = `${analysisBase}/daily_news_categorized_${dateParam}.json`;

  $("btnOpenCategorized").onclick = () => window.open(dateParam === "latest" ? catLatestUrl : catDatedUrl, "_blank");
  $("btnOpenSentiment").onclick = () => window.open(sentLatestUrl, "_blank");
  $("btnOpenTimeseries").onclick = () => window.open(tsUrl, "_blank");
  $("btnReload").onclick = () => reload();
  $("btnReset").onclick = () => {
    $("q").value = "";
    $("sourceSel").value = "__all__";
    $("sortSel").value = "risk_desc";
    $("showMissing").checked = true;
    state.category = "All";
    renderAll();
  };

  const state = {
    date: dateParam,
    category: "All",
    base: "categorized",   // or "sentiment"
    note: "",
    debug: {},
    rows: [],              // final rows for table
    categories: ["All"],
    sources: ["__all__"],
    raw: {
      categorized: [],
      sentiment: [],
      sentKeyMap: new Map(),
      sentKeyCount: 0,
    }
  };

  async function fetchJson(url){
    const r = await fetch(url, { cache: "no-store" });
    if (!r.ok) throw new Error(`fetch failed: ${url} (${r.status})`);
    return await r.json();
  }

  async function fetchText(url){
    const r = await fetch(url, { cache: "no-store" });
    if (!r.ok) throw new Error(`fetch failed: ${url} (${r.status})`);
    return await r.text();
  }

  function getItems(doc){
    if (Array.isArray(doc)) return doc;
    const xs = pick(doc, ["items","articles","rows","data"]);
    return Array.isArray(xs) ? xs : [];
  }

  function buildSentKeyMap(sentItems){
    const map = new Map();
    let totalKeys = 0;

    for (const s of sentItems){
      const urlRaw = pickUrlAny(s);
      const urlNorm = safeStr(pick(s, ["norm_url","normUrl"])).trim();
      const title = pickTitleAny(s);
      const source = pickSourceAny(s);

      const keys = buildKeys({ urlNorm, urlRaw, title, source });
      for (const k of keys){
        totalKeys += 1;
        if (!map.has(k)) map.set(k, s);
      }
    }
    return { map, totalKeys };
  }

  function joinCategorizedToSentiment(catItems, sentKeyMap){
    const out = [];
    let joined = 0;

    for (const c of catItems){
      const urlRaw = pickUrlAny(c);
      const urlNorm = normalizeUrl(urlRaw);
      const title = pickTitleAny(c);
      const source = pickSourceAny(c);

      const keys = buildKeys({ urlNorm, urlRaw, title, source });
      let hit = null;
      for (const k of keys){
        if (sentKeyMap.has(k)){ hit = sentKeyMap.get(k); break; }
      }

      const score = hit ? pickScoreTriplet(hit) : {net:null,risk:null,pos:null,unc:null};

      if (hit) joined += 1;

      const cat = safeStr(pick(c, ["category"])).trim() || "General";
      const img = safeStr(pick(c, ["urlToImage","image_url","imageUrl"])).trim() || safeStr(pick(hit || {}, ["image_url","urlToImage","imageUrl"])).trim();
      const pub = safeStr(pick(c, ["publishedAt","published_at","pubDate","date"])).trim() || safeStr(pick(hit || {}, ["published_at","publishedAt","date"])).trim();

      out.push({
        base: "categorized",
        category: cat,
        title: title || "(no title)",
        source: source || "(unknown)",
        url: urlRaw || "",
        image: img || "",
        publishedAt: pub || "",
        hasScore: (score.risk !== null || score.pos !== null || score.unc !== null || score.net !== null),
        score,
      });
    }
    return { rows: out, joined };
  }

  function rowsFromSentiment(sentItems){
    const out = [];
    for (const s of sentItems){
      const title = pickTitleAny(s) || "(no title)";
      const source = pickSourceAny(s) || "(unknown)";
      const url = pickUrlAny(s) || "";
      const img = safeStr(pick(s, ["image_url","urlToImage","imageUrl"])).trim();
      const pub = safeStr(pick(s, ["published_at","publishedAt","date"])).trim();
      const score = pickScoreTriplet(s);

      out.push({
        base: "sentiment",
        category: "General",
        title,
        source,
        url,
        image: img || "",
        publishedAt: pub || "",
        hasScore: (score.risk !== null || score.pos !== null || score.unc !== null || score.net !== null),
        score,
      });
    }
    return out;
  }

  function buildCategories(rows){
    const set = new Set(["All"]);
    for (const r of rows){
      if (r.category) set.add(r.category);
    }
    return Array.from(set);
  }

  function buildSources(rows){
    const set = new Set(["__all__"]);
    for (const r of rows){
      const s = (r.source || "").trim();
      if (s) set.add(s);
    }
    return Array.from(set).sort((a,b) => a.localeCompare(b));
  }

  function sumKpis(rows){
    let n = 0, sr = 0, sp = 0, su = 0;
    for (const r of rows){
      if (!r.hasScore) continue;
      // risk/pos/unc が null の場合は 0 として扱う（見える値を優先）
      sr += (r.score.risk ?? 0);
      sp += (r.score.pos ?? 0);
      su += (r.score.unc ?? 0);
      n += 1;
    }
    return { scoredRows: n, risk: sr, pos: sp, unc: su };
  }

  function renderTabs(){
    const wrap = $("catTabs");
    wrap.innerHTML = "";
    for (const cat of state.categories){
      const b = document.createElement("button");
      b.className = "gp-tab mono" + (cat === state.category ? " active" : "");
      b.textContent = cat;
      b.onclick = () => { state.category = cat; renderAll(); };
      wrap.appendChild(b);
    }
  }

  function renderSourceSel(){
    const sel = $("sourceSel");
    sel.innerHTML = "";
    const optAll = document.createElement("option");
    optAll.value = "__all__";
    optAll.textContent = "All";
    sel.appendChild(optAll);

    for (const s of state.sources){
      if (s === "__all__") continue;
      const o = document.createElement("option");
      o.value = s;
      o.textContent = s;
      sel.appendChild(o);
    }
  }

  function getFiltered(){
    const q = $("q").value.trim().toLowerCase();
    const src = $("sourceSel").value;
    const showMissing = $("showMissing").checked;

    let rows = state.rows.slice();

    if (state.category !== "All"){
      rows = rows.filter(r => (r.category || "General") === state.category);
    }
    if (src && src !== "__all__"){
      rows = rows.filter(r => (r.source || "") === src);
    }
    if (q){
      rows = rows.filter(r => {
        const t = (r.title || "").toLowerCase();
        const s = (r.source || "").toLowerCase();
        return t.includes(q) || s.includes(q);
      });
    }
    if (!showMissing){
      rows = rows.filter(r => r.hasScore);
    }
    return rows;
  }

  function sortRows(rows){
    const mode = $("sortSel").value;

    const byTimeDesc = (a,b) => (String(b.publishedAt||"").localeCompare(String(a.publishedAt||"")));
    const byRiskDesc = (a,b) => ((b.score.risk ?? -1e9) - (a.score.risk ?? -1e9));
    const byPosDesc  = (a,b) => ((b.score.pos ?? -1e9) - (a.score.pos ?? -1e9));
    const byUncDesc  = (a,b) => ((b.score.unc ?? -1e9) - (a.score.unc ?? -1e9));
    const byNetAsc   = (a,b) => ((a.score.net ?? 1e9) - (b.score.net ?? 1e9));
    const byNetDesc  = (a,b) => ((b.score.net ?? -1e9) - (a.score.net ?? -1e9));

    const m = {
      "time_desc": byTimeDesc,
      "risk_desc": byRiskDesc,
      "pos_desc": byPosDesc,
      "unc_desc": byUncDesc,
      "net_asc": byNetAsc,
      "net_desc": byNetDesc,
    }[mode] || byRiskDesc;

    return rows.sort(m);
  }

  function renderTable(rows){
    const tb = $("tbody");
    tb.innerHTML = "";

    if (!rows.length){
      const tr = document.createElement("tr");
      const td = document.createElement("td");
      td.colSpan = 8;
      td.className = "mono";
      td.textContent = "no rows";
      tr.appendChild(td);
      tb.appendChild(tr);
      return;
    }

    for (const r of rows){
      const tr = document.createElement("tr");

      // thumb
      const td0 = document.createElement("td");
      const img = document.createElement("img");
      img.className = "thumb";
      img.loading = "lazy";
      img.referrerPolicy = "no-referrer";
      img.decoding = "async";
      if (r.image) img.src = r.image;
      td0.appendChild(img);
      tr.appendChild(td0);

      // title
      const td1 = document.createElement("td");
      td1.className = "t-title";
      const a = document.createElement("a");
      a.href = r.url || "#";
      a.target = "_blank";
      a.rel = "noopener noreferrer";
      a.textContent = r.title;
      td1.appendChild(a);
      const sub = document.createElement("div");
      sub.className = "gp-small mono";
      sub.style.marginTop = "4px";
      sub.textContent = r.source + (r.publishedAt ? ("  ·  " + r.publishedAt) : "");
      td1.appendChild(sub);
      tr.appendChild(td1);

      // category
      const td2 = document.createElement("td");
      td2.className = "mono";
      td2.textContent = r.category || "General";
      tr.appendChild(td2);

      // status
      const td3 = document.createElement("td");
      const badge = document.createElement("span");
      badge.className = "badge mono";
      const dot = document.createElement("span");
      dot.className = "dot " + (r.hasScore ? ((r.score.net ?? 0) < 0 ? "risk" : "ok") : "");
      badge.appendChild(dot);
      const label = document.createElement("span");
      label.textContent = r.hasScore ? "ok" : "missing";
      badge.appendChild(label);
      td3.appendChild(badge);
      tr.appendChild(td3);

      // numbers
      const td4 = document.createElement("td"); td4.className = "mono num"; td4.textContent = r.hasScore ? fmt6(r.score.risk ?? 0) : "—";
      const td5 = document.createElement("td"); td5.className = "mono num"; td5.textContent = r.hasScore ? fmt6(r.score.pos ?? 0) : "—";
      const td6 = document.createElement("td"); td6.className = "mono num"; td6.textContent = r.hasScore ? fmt6(r.score.unc ?? 0) : "—";

      const td7 = document.createElement("td");
      const net = r.score.net;
      td7.className = "mono net " + (net === null ? "" : (net >= 0 ? "pos" : "neg"));
      td7.textContent = (net === null || net === undefined || Number.isNaN(net)) ? "—" : fmt3(net);

      tr.appendChild(td4); tr.appendChild(td5); tr.appendChild(td6); tr.appendChild(td7);

      tb.appendChild(tr);
    }
  }

  // -----------------------
  // Trend: 3-panel canvas + B1 (latest value labels)
  // -----------------------
  function renderTrendFromCsv(csvText){
    const c = $("trend");
    const ctx = c.getContext("2d");

    // reset transform + clear (avoid cumulative scale)
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,c.width,c.height);

    // scale canvas for crispness
    const rect = c.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    c.width = Math.max(1, Math.floor(rect.width * dpr));
    c.height = Math.max(1, Math.floor(rect.height * dpr));
    ctx.setTransform(dpr,0,0,dpr,0,0);

    const text = (csvText || "").trim();
    if (!text) return;

    const lines = text.split(/\r?\n/).filter(x => x.trim().length > 0);
    if (lines.length <= 1) return;

    // header detect
    const header = lines[0].split(",").map(s => s.trim().toLowerCase());
    const idxDate = header.indexOf("date") >= 0 ? header.indexOf("date") : 0;
    const idxRisk = header.indexOf("risk");
    const idxPos  = header.indexOf("positive");
    const idxUnc  = header.indexOf("uncertainty");

    // fallback (legacy: date,risk,positive,uncertainty)
    const rIdx = (idxRisk >= 0) ? idxRisk : 1;
    const pIdx = (idxPos  >= 0) ? idxPos  : 2;
    const uIdx = (idxUnc  >= 0) ? idxUnc  : 3;

    const pts = [];
    for (let i=1;i<lines.length;i++){
      const cols = lines[i].split(",");
      if (cols.length <= Math.max(idxDate, rIdx, pIdx, uIdx)) continue;

      const date = (cols[idxDate] || "").trim();
      if (!date) continue;

      const risk = Number(cols[rIdx]);
      const pos  = Number(cols[pIdx]);
      const unc  = Number(cols[uIdx]);

      pts.push({
        date,
        risk: Number.isFinite(risk) ? risk : 0,
        pos:  Number.isFinite(pos)  ? pos  : 0,
        unc:  Number.isFinite(unc)  ? unc  : 0
      });
    }
    if (!pts.length) return;

    const w = rect.width;
    const h = rect.height;

    // layout
    const padL = 42, padR = 64, padT = 10, padB = 22;  // padR a bit larger for labels
    const gap = 8;

    const plotX0 = padL;
    const plotX1 = w - padR;

    const innerH = (h - padT - padB);
    const panelH = (innerH - gap*2) / 3;

    const panels = [
      { key: "risk", label: "risk",       y0: padT + 0*(panelH+gap), y1: padT + 0*(panelH+gap) + panelH, stroke: "rgba(251,113,133,.92)" },
      { key: "pos",  label: "positive",   y0: padT + 1*(panelH+gap), y1: padT + 1*(panelH+gap) + panelH, stroke: "rgba(45,212,191,.92)"  },
      { key: "unc",  label: "uncert.",    y0: padT + 2*(panelH+gap), y1: padT + 2*(panelH+gap) + panelH, stroke: "rgba(250,204,21,.92)"   },
    ];

    function xAt(i){
      if (pts.length === 1) return (plotX0 + plotX1) / 2;
      return plotX0 + (plotX1 - plotX0) * (i / (pts.length - 1));
    }

    function yAt(v, y0, y1, vmax){
      const vv = Math.max(0, v);
      const den = (vmax > 0) ? vmax : 1;
      return y1 - (y1 - y0) * (vv / den);
    }

    function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }

    // Common font
    const mono = "ui-monospace, Menlo, Consolas, monospace";

    // Draw each panel
    for (const p of panels){
      // vmax per panel
      let vmax = 0;
      for (const pt of pts) vmax = Math.max(vmax, pt[p.key] || 0);
      if (vmax <= 0) vmax = 1;

      // grid
      ctx.globalAlpha = 0.6;
      ctx.strokeStyle = "rgba(255,255,255,.14)";
      ctx.lineWidth = 1;

      for (let g=0; g<=2; g++){
        const y = p.y0 + (p.y1 - p.y0) * (g / 2);
        ctx.beginPath();
        ctx.moveTo(plotX0, y);
        ctx.lineTo(plotX1, y);
        ctx.stroke();
      }

      // left axis
      ctx.globalAlpha = 0.75;
      ctx.beginPath();
      ctx.moveTo(plotX0, p.y0);
      ctx.lineTo(plotX0, p.y1);
      ctx.stroke();

      // label
      ctx.globalAlpha = 0.85;
      ctx.fillStyle = "rgba(255,255,255,.85)";
      ctx.font = `12px ${mono}`;
      ctx.fillText(p.label, 6, p.y0 + 12);

      // line
      ctx.globalAlpha = 1.0;
      ctx.strokeStyle = p.stroke;
      ctx.lineWidth = 2;

      ctx.beginPath();
      for (let i=0;i<pts.length;i++){
        const x = xAt(i);
        const y = yAt(pts[i][p.key] || 0, p.y0, p.y1, vmax);
        if (i === 0) ctx.moveTo(x,y);
        else ctx.lineTo(x,y);
      }
      ctx.stroke();

      // B1: latest value label at right
      const last = pts[pts.length - 1];
      const lastVal = Number(last[p.key] || 0);
      const xLast = xAt(pts.length - 1);
      const yLast = yAt(lastVal, p.y0, p.y1, vmax);

      const labelText = lastVal.toFixed(4); // concise but informative
      ctx.font = `12px ${mono}`;

      // measure + draw small pill background
      const m = ctx.measureText(labelText);
      const boxW = Math.ceil(m.width) + 10;
      const boxH = 18;

      const xBox = plotX1 + 8; // in right margin area
      const yBox = clamp(yLast - boxH/2, p.y0 + 2, p.y1 - boxH - 2);

      ctx.globalAlpha = 0.85;
      ctx.fillStyle = "rgba(0,0,0,.55)";
      ctx.strokeStyle = "rgba(255,255,255,.18)";
      ctx.lineWidth = 1;
      // rounded rect
      const r = 6;
      ctx.beginPath();
      ctx.moveTo(xBox + r, yBox);
      ctx.lineTo(xBox + boxW - r, yBox);
      ctx.quadraticCurveTo(xBox + boxW, yBox, xBox + boxW, yBox + r);
      ctx.lineTo(xBox + boxW, yBox + boxH - r);
      ctx.quadraticCurveTo(xBox + boxW, yBox + boxH, xBox + boxW - r, yBox + boxH);
      ctx.lineTo(xBox + r, yBox + boxH);
      ctx.quadraticCurveTo(xBox, yBox + boxH, xBox, yBox + boxH - r);
      ctx.lineTo(xBox, yBox + r);
      ctx.quadraticCurveTo(xBox, yBox, xBox + r, yBox);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();

      // value text colored by series
      ctx.globalAlpha = 1.0;
      ctx.fillStyle = p.stroke;
      ctx.fillText(labelText, xBox + 5, yBox + 13);

      // small marker at last point
      ctx.globalAlpha = 1.0;
      ctx.fillStyle = p.stroke;
      ctx.beginPath();
      ctx.arc(xLast, yLast, 2.8, 0, Math.PI*2);
      ctx.fill();
    }

    // x labels (first/last)
    ctx.globalAlpha = 0.75;
    ctx.fillStyle = "rgba(255,255,255,.75)";
    ctx.font = `12px ${mono}`;
    ctx.fillText(pts[0].date, plotX0, h - 6);
    const lastDate = pts[pts.length - 1].date;
    ctx.fillText(lastDate, Math.max(plotX0, plotX1 - 92), h - 6);
    ctx.globalAlpha = 1.0;
  }

  function renderAll(){
    // KPIs
    const k = sumKpis(state.rows);
    $("kpiDate").textContent = state.date;
    $("kpiArticles").textContent = String(state.rows.length);
    $("kpiRisk").textContent = fmt6(k.risk);
    $("kpiPos").textContent  = fmt6(k.pos);
    $("kpiUnc").textContent  = fmt6(k.unc);
    $("kpiNote").textContent = state.note;

    // tabs/sources
    renderTabs();
    renderSourceSel();

    // filter + sort + table
    let rows = getFiltered();
    rows = sortRows(rows);
    renderTable(rows);

    // statline
    $("statLine").textContent =
      `showing: ${rows.length} / total: ${state.rows.length}  |  base=${state.base}  |  joined=${state.debug.joined}/${state.debug.catCount}  |  sentItems=${state.debug.sentCount}`;

    // debug box
    $("debugBox").textContent = [
      `date=${state.date}`,
      `base=${state.base}`,
      `categorized=${state.debug.catCount}`,
      `sentiment=${state.debug.sentCount}`,
      `sentKeyMap=${state.debug.sentKeyMap}`,
      `joined=${state.debug.joined}`,
      `catUrl=${state.debug.catUrl}`,
      `sentUrl=${state.debug.sentUrl}`,
      `note=${state.note}`
    ].join("\n");
  }

  async function reload(){
    $("noteLine").textContent = "loading...";
    $("tbody").innerHTML = `<tr><td colspan="8" class="mono">loading...</td></tr>`;

    // health pill: date表示だけ（ここは将来 health.json に寄せてもOK）
    $("healthText").textContent = `OK: ${dateParam === "latest" ? "--" : dateParam}`;
    $("healthDot").className = "dot ok";

    let catDoc = null;
    let sentDoc = null;

    // 1) categorized
    let catUrl = (dateParam === "latest") ? catLatestUrl : catDatedUrl;
    try {
      catDoc = await fetchJson(catUrl);
    } catch (e) {
      // dated が無い場合は latest にフォールバック
      catUrl = catLatestUrl;
      try { catDoc = await fetchJson(catUrl); }
      catch (e2) { catDoc = null; }
    }

    // 2) sentiment
    try {
      sentDoc = await fetchJson(sentLatestUrl);
    } catch (e) {
      sentDoc = null;
    }

    const catItems = catDoc ? getItems(catDoc) : [];
    const sentItems = sentDoc ? getItems(sentDoc) : [];

    state.raw.categorized = catItems;
    state.raw.sentiment = sentItems;

    // build sentiment key map
    const { map: sentKeyMap, totalKeys } = buildSentKeyMap(sentItems);
    state.raw.sentKeyMap = sentKeyMap;
    state.raw.sentKeyCount = totalKeys;

    // try join
    const joinedResult = joinCategorizedToSentiment(catItems, sentKeyMap);

    // Decide base (B)
    // - overlap が 0 か、極端に低い場合は sentiment を母集団にする
    const catCount = catItems.length;
    const joined = joinedResult.joined;
    const joinRate = (catCount > 0) ? (joined / catCount) : 0;

    let rows;
    if (sentItems.length > 0 && (catCount === 0 || joined === 0 || joinRate < 0.15)){
      state.base = "sentiment";
      rows = rowsFromSentiment(sentItems);
      state.note = "base mismatch detected → fallback base: sentiment (scores visible)";
      // category tabs は General だけ
    } else {
      state.base = "categorized";
      rows = joinedResult.rows;
      state.note = "base: categorized → join: norm_url → url → title+source → title";
    }

    // categories & sources
    state.rows = rows;
    state.categories = buildCategories(rows);
    state.sources = buildSources(rows);

    // default category keep if exists else All
    if (!state.categories.includes(state.category)) state.category = "All";

    // debug stats
    state.debug = {
      catCount,
      sentCount: sentItems.length,
      sentKeyMap: totalKeys,
      joined,
      catUrl,
      sentUrl: sentLatestUrl,
    };

    $("noteLine").textContent = state.note;

    // trend (optional)
    try {
      const csv = await fetchText(tsUrl);
      renderTrendFromCsv(csv);
    } catch (e) {
      // no trend: just clear canvas (already cleared by renderTrendFromCsv scale init on first successful render)
      const c = $("trend");
      const ctx = c.getContext("2d");
      ctx.setTransform(1,0,0,1,0,0);
      ctx.clearRect(0,0,c.width,c.height);
    }

    renderAll();
  }

  // filter events
  $("q").addEventListener("input", () => renderAll());
  $("sourceSel").addEventListener("change", () => renderAll());
  $("sortSel").addEventListener("change", () => renderAll());
  $("showMissing").addEventListener("change", () => renderAll());

  // go
  reload();
})();
</script>

</body>
</html>